# -*- coding: utf-8 -*-
"""Calmcode 2 -DSBA 6188

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16TRMdVsLHDs79fPJcptPbAgG9YFazJHc

# **[Python loops/lists: comprehensions]**
"""

# The loop is going into the original list and multiplying it by 2
old_list = [1,2,3,4,5]
new_list = []
for i in old_list:
  new_list.append(i * 2)
new_list

# This code does the same as above. Its called a list comprehension
[i * 2 for i in old_list]

# Adding an If statement in the long code
old_list = [1,2,3,4,5]
new_list = []
for i in old_list:
  if i % 2 == 0:
    new_list.append(i * 2)
new_list

# Code does the same as above
[i * 2 for i in old_list if i % 2 == 0]

# if i % 2 == 0 is used for filtering
[i * 2 if i > 3 else i * 3 for i in old_list if i % 2 == 0]

# This code gets every other letter
old_list = 'abcde'
new_list = []
for i in range (len(old_list)):
  if i % 2 == 0:
    new_list.append(old_list[i])
new_list

# this is a simpler version of the code above
[char for idx, char in enumerate('abcde') if idx % 2 == 0]

# This code will check for even letter and if they are vowels it will capitalize it
old_list = 'abcde'
new_list = []
for i, c in enumerate(old_list):
    if i % 2 == 0:
        if c in 'aeuio':
            char = c.upper()
        else:
            char = c
        new_list.append(char)
new_list

#Comprehension code
[c.upper() if c in 'aeuio' else c
 for i,c in enumerate(old_list)
 if i % 2 == 0]

# This is a nested for loop
for i in range(5):
    for j in range(i):
        print((i, j))

#Comprehension nested for loop
[(i, j) for i in range(5) for j in range(i)]

for i in range(5):
    if i > 2:
        for j in range(i):
            if j < 2:
                print((i, j))

[(i, j) for i in range(5) if i > 2 for j in range(i) if j < 2]

[c for c in 'abceabce']

# This is a set that doesnt allow duplicates
set([1,1,2,3])

{i: c for i, c in enumerate('abceabce') if i < 5}

{'a':1}

# Dictionary comprehensions
{i: c for i, c in enumerate('abcdefa')}

{c: i for i, c in enumerate('abcdefa')}

arr = [('a', 1), ('b', 2), ('c', 2)]

# new variant of comprehensions
for thing in enumerate(arr):
  print(thing)

for idx, (char, i) in enumerate(arr):
    print(idx, char, i)

[{key: value, 'i': idx} for idx, (key, value) in enumerate(arr)]

# The items allows you to unpack and get a comprehensions
d = {'a': 1, 'b': 2, 'c': 3}
[(k, v) for k, v in d.items()]

# Zip allows you to list things together
[(a, b, c) for a, b, c in zip([1, 2, 3], [4, 5, 6], [7, 8, 9])]

"""# **Python popular ML library: Scikit-learnLinks **"""

#%pip install --force-reinstall "scikit-learn==1.0.2"

# We have to downgrade to a different version to load the boston dataset

#%pip install matplotlib

from sklearn.datasets import load_boston
X, y = load_boston(return_X_y=True)

from sklearn.neighbors import KNeighborsRegressor
from sklearn.linear_model import LinearRegression

# Training the model
mod = LinearRegression()
mod.fit(X, y)
mod.predict(X)

#KNeighborsRegressor
import matplotlib.pylab as plt
mod = KNeighborsRegressor().fit(X, y)
pred = mod.predict(X)
plt.scatter(pred, y)

#Pipelines
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import Pipeline
pipe = Pipeline([
    ("scale", StandardScaler()),
    ("model", KNeighborsRegressor())
])

pipe.fit(X, y)
pred = pipe.predict(X)

plt.scatter(pred,y)

pipe = Pipeline([
    ("scale", StandardScaler()),
    ("model", KNeighborsRegressor(n_neighbors=1))
])
pipe.fit(X, y)
pred = pipe.predict(X)
plt.scatter(pred,y)

#Grid Search
from sklearn.model_selection import GridSearchCV
import pandas as pd

pipe = Pipeline([
    ("scale", StandardScaler()),
    ("model", KNeighborsRegressor(n_neighbors=1))
])

mod = GridSearchCV(estimator=pipe,
                   param_grid={
                     'model__n_neighbors': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
                   },
                   cv=3)

mod.fit(X, y);
pd.DataFrame(mod.cv_results_)

load_boston()

# This dataset has many ethical concerns
print(load_boston()['DESCR'])